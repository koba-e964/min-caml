min_caml_print_int
min_caml_print_int_bin ; print int(4bytes) in little-endian format. int -> int (unit)
	MOV R0, R2
	MOV #-8, R1
	WRITE R2
	SHLD R1, R2
	WRITE R2
	SHLD R1, R2
	WRITE R2
	SHLD R1, R2
	WRITE R2
	RTS
	AND R0, R0

min_caml_print_char
	WRITE R0
	RTS
	AND R0, R0

min_caml_read_int
min_caml_read_int_bin ; read int(4bytes) in little-endian format.
	READ R0

	MOV #8, R2
	READ R1
	SHLD R2, R1
	OR R1, R0

	MOV #16, R2
	READ R1
	SHLD R2, R1
	OR R1, R0

	MOV #24, R2
	READ R1
	SHLD R2, R1
	OR R1, R0
	RTS
	AND R0, R0

min_caml_read_float
min_caml_read_float_bin
	MOV.L .mcrfb0, R14
	JSR @R14
	AND R0, R0
	BRA .mcrfb1
	AND R0, R0
.mcrfb0
	.data.l min_caml_read_int_bin
.mcrfb1
	LDS R0, FPUL
	FSTS FPUL, FR0
	RTS
	AND R0, R0

min_caml_truncate
min_caml_int_of_float
	FTRC FR0, FPUL
	STS FPUL, R0
	RTS
	AND R0, R0

min_caml_float_of_int
	LDS R0, FPUL
	FLOAT FPUL, FR0
	RTS
	AND R0, R0

min_caml_fabs
min_caml_abs_float
	FLDI0 FR1
	FCMP/GT FR1, FR0
	BT .mcaf0
	FNEG FR0
.mcaf0
	RTS
	AND R0, R0

min_caml_sqrt
	FSQRT FR0
	RTS
	AND R0, R0

min_caml_sin	; sin(x) = x
	FMOV FR0, FR1
	FLDI1 FR2
	FLDI1 FR3
	FLDI0 FR4 ; sum = 0
	FMOV FR0, FR5 ; cur = x
	FMUL FR1, FR1 ; x*x
	MOV #31, R0 ; cnt
	MOV #0, R1 
.mcs0
	FADD FR5, FR4 ; sum += cur
	FADD FR3, FR2 ; div += 1.0
	FMUL FR1, FR5 ; cur *= x * x
	FDIV FR2, FR5 ; cur = cur / div
	FADD FR3, FR2 ; div += 1.0
	FDIV FR2, FR5 ; cur = cur / div
	FNEG FR5      ; cur = -cur
	ADD #-1, R0   ; cnt--
	CMP/GT R1, R0
	BT .mcs0  ; if cnt > 0 then goto .mcs0

	FMOV FR4, FR0
	RTS
	AND R0, R0

min_caml_cos	; cos(x) = x
	FMOV FR0, FR1
	FLDI0 FR2 ; div = 0
	FLDI1 FR3
	FLDI0 FR4 ; sum = 0
	FLDI1 FR5 ; cur = 1
	FMUL FR1, FR1 ; x*x
	MOV #31, R0 ; cnt
	MOV #0, R1 
.mcc0
	FADD FR5, FR4 ; sum += cur
	FADD FR3, FR2 ; div += 1.0
	FMUL FR1, FR5 ; cur *= x * x
	FDIV FR2, FR5 ; cur = cur / div
	FADD FR3, FR2 ; div += 1.0
	FDIV FR2, FR5 ; cur = cur / div
	FNEG FR5      ; cur = -cur
	ADD #-1, R0   ; cnt--
	CMP/GT R1, R0
	BT .mcs0  ; if cnt > 0 then goto .mcs0

	FMOV FR4, FR0
	RTS
	AND R0, R0

	RTS
	AND R0, R0
min_caml_atan ; atan(x) = x
	RTS
	AND R0, R0

min_caml_fiszero ; float -> bool
	FLDI0 FR1
	MOV #1, R0
	FCMP/EQ FR1, FR0
	BT .mcfi0_0
	MOV #0, R0
.mcfi0_0
	RTS
	AND R0, R0

min_caml_fispos ; float -> bool
	FLDI0 FR1
	MOV #1, R0
	FCMP/GT FR1, FR0
	BT .mcfip_0
	MOV #0, R0
.mcfip_0
	RTS
	AND R0, R0

min_caml_fisneg ; float -> bool
	FLDI0 FR1
	MOV #1, R0
	FCMP/GT FR0, FR1
	BT .mcfip_0
	MOV #0, R0
.mcfin_0
	RTS
	AND R0, R0

min_caml_fneg
	FNEG FR0
	RTS
	AND R0, R0

min_caml_fsqr
	FMUL FR0, FR0
	RTS
	AND R0, R0

min_caml_fless
	MOV #1, R0
	FCMP/GT FR0, FR1
	BT .mcfless0
	MOV #0, R0
.mcfless0
	RTS
	AND R0, R0

min_caml_fhalf
	FLDI1 FR1
	FADD FR1, FR1
	FDIV FR1, FR0
	RTS
	AND R0, R0
min_caml_floor ; TODO not correct implementation
	FTRC FR0, FPUL
	STS FPUL, R0
	RTS
	AND R0, R0

min_caml_create_array ; int -> 'a -> 'a array
	MOV R12, R3
	MOV R3, R6 ; old_min_caml_hp
	MOV R0, R4
.mcca2
	MOV #0, R5
	CMP/GT R5, R4
	BF .mcca3
	MOV.L R1, @R3 ; element
	ADD #4, R3
	ADD #-1, R4
	BRA .mcca2
	AND R0, R0
.mcca3
	MOV R3, R12
	MOV R6, R0
	RTS
	AND R0, R0

min_caml_create_float_array ; int -> float -> float array
	MOV R12, R3
	MOV R3, R6 ; old_min_caml_hp
	MOV R0, R4
.mccfa2
	MOV #0, R5
	CMP/GT R5, R4
	BF .mccfa3
	FMOV.S FR0, @R3 ;element
	ADD #4, R3
	ADD #-1, R4
	BRA .mccfa2
	AND R0, R0
.mccfa3
	MOV R3, R12
	MOV R6, R0
	RTS
	AND R0, R0

	.align


